# Q1: Probability of At‑Least‑_`n`_ Rainy Days in a Year

> The probability of rain on a given calendar day in Vancouver is `p[i]`, where i is the day's index. For example, `p[0]` is the probability of rain on January 1st, and `p[10]` is the probability of precipitation on January 11th. Assume the year has 365 days (i.e., `p` has 365 elements). What is the chance it rains more than `n` (e.g., 100) days in Vancouver? Write a function that accepts `p` (probabilities of rain on a given calendar day) and n as input arguments and returns the possibility of raining at least `n` days.
>
> ```python
> def prob_rain_more_than_n(p: Sequence[float], n: int) -> float:
> pass
> ```
>



## 1. Assumptions

1. **days are independent.** Rain on one day does not affect other days.
2. **daily probability is given.** For each day $$i$$, we know, $$ p_i$$\.
3. **Each year has 365 days.** $$N=365$$ 

----


 We can formulate this problem as

$$
P(R>n) \;=\; P(R\ge n+1)
$$
where **R** is the total number of rainy days, and we want the probability that **at least** `n+1` days are rainy. For simplicity, lets ignore $$+1$$ and solve $$P(R\ge n)$$.

---

Random variables for each day:
$$
X_i \;=\; 
\begin{cases}
1, & \text{if it rains},\\[2pt]
0, & \text{otherwise,}
\end{cases}
\qquad
\Pr(X_i=1)=p_i,\ \ \Pr(X_i=0)=1-p_i.
$$

The total number of rainy days:
$$
R \;=\; \sum_{i=1}^{N} X_i \quad (\text{with } N=365).
$$

daily rain probabilities :
$$
p=(p_1,\dots,p_N)
$$

---



We want the upper tail:
$$
\Pr(R\ge n) \;=\; \sum_{r=n}^{N} \Pr(R=r),
$$
or
$$
\Pr(R>n) \;=\; \sum_{r=n+1}^{N} \Pr(R=r) \;=\; \Pr(R\ge n+1).
$$

---

A non-efficient solution would cost $$O(2^{n=365})$$ to check every possible permutation!  



## 2. Dynamic Programming

When we add day  $j$ with probability $p_j$, the distribution updates:
$$
f_j(r)\;=\;f_{j-1}(r)\,(1-p_j)\;+\;f_{j-1}(r-1)\,p_j,\qquad f_{j-1}(-1)\equiv 0.
$$

Using the law of total probability, we implement this with a one‑dimensional dynamic programming array `dp[k]` holding the current probability. We updated from right to left to we don’t overwrite values in the same iteration.

Then, we return
$$
\Pr(K\ge n)\;=\;\sum_{k=n}^{N} \texttt{dp}[k].
$$

---

## 3. Implementation



```python
See p1.py

>>
P(K >= 150) = 0.3531078124043988
P(K > 150)  = 0.3143877092908275


Process finished with exit code 0

```



