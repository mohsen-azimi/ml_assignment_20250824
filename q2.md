# Q2: Phoneme Segmentation

> A phoneme is a sound unit (similar to a character for text). We have an extensive pronunciation dictionary (think millions of words). Below is a snippet :
>
> ```python
> WORD     phonemes
> ----------------------------
> ABACUS   AE B AH K AH S
> BOOK     B UH K
> THEIR    DH EH R
> THERE    DH EH R
> TOMATO   T AH M AA T OW
> TOMATO   T AH M EY T OW
> ```
>
> **Task.**  
> Given a sequence of phonemes as input (e.g. `["DH", "EH", "R", "DH", "EH", "R"]`), find all the combinations of words that can produce this sequence (e.g., `["THEIR", "THEIR"],["THEIR", "THERE"],
> ["THERE", "THEIR"],["THERE", "THERE"]`). You can preprocess the dictionary into a different data structure if needed .
>
> ````python
> def find_word_combos_with_pronunciation(phonemes: Sequence[str]) -> Sequence[Sequence[str]]:
>     pass
> ````
>
> 





**Notes:**

- We may have a word with different pronunciations, or have different words with similar/same pronunciation.  
- If the dictionary is large; we want some efficient algorithm (like DP).

**Goal:** 

List all possible sequences of dictionary words whose pronunciations match the input phoneme sequence.

Input phoneme sequence:
$$
P = \langle p_0, p_1, \dots, p_{n-1} \rangle.
$$

Let $$\mathrm{Pron}(w)$$ be the pronunciation(s) of word $$w$$ as one or more phoneme. We require:
$$
[w_1, w_2, \dots, w_k]
$$


---

## 1) Dynamic Programming

We define:
$$
F(i) = \{\, \text{all word sequences that have the suffix } P[i:] \,\}.
$$

Base case:
$$
F(n) = \{\,[\,]\,\},
$$
Recursion:

For every $$i\to j$$ word $$w$$ (a phenome that matches $$P[i:j]$$),
$$
F(i) \,=\, \bigcup_{(i,j,w)} \big\{\, [w] \;+ s \;:\; s \in F(j) \,\big\}.
$$



---

## 2) Prefix Tree of Phonemes

We need to know which pronunciations match the prefix of $$P[i:]$$.

We need a prefix tree over phonemes (for efficiency as suggested in paper).

So, each node is a dictionary with two fields:

```python
node = {
    "branches": {},  
    "leaves": []     
}
```

**Complexity :** building the tree is $$O(T)$$, where $$T$$ is the total number of phonemes.  We run in about $$O(n\cdot B)$$ ($$B$$ is branching factor) + the time to output all solutions.

---

## 3) Implementation

```python
q2.py

>>
Inputs: ['DH', 'EH', 'R', 'T', 'AH', 'M', 'AA', 'T', 'OW']
|Solutions:
|__ ['THEIR', 'TOMATO']
|__ ['THERE', 'TOMATO']

-------------------
Inputs: ['DH', 'EH', 'R', 'T', 'AH', 'M', 'AA', 'T', 'AH']
|Solutions:
```

---

